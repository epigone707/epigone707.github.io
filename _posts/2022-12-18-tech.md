---
layout: post
title: "C++ Interview Note"
description: ""
category: tech
tags: c++ interview
modify: 2022-12-19 12:09:00
---

# Contents
* TOC
{:toc}
# Intro

This is a note for my c++ SWE interview.


# Questions I came accross

## How to stop people deriving from my class?

source: [Bjarne Stroustrup's FAQ](https://www.stroustrup.com/bs_faq2.html#no-derivation)

First, why do you want to? There are two common answers:

- for efficiency: to avoid my function calls being virtual
- for safety: to ensure that my class is not used as a base class (for example, to be sure that I can copy objects without fear of slicing)

According to Stroustrup, 
> the efficiency reason is usually misplaced fear. In C++, virtual function calls are so fast that their real-world use for a class designed with virtual functions does not to produce measurable run-time overheads compared to alternative solutions using ordinary function calls. Note that the virtual function call mechanism is typically used only when calling through a pointer or a reference. When calling a function directly for a named object, the virtual function class overhead is easily optimized away.

Ok, now how to stop people deriving from my class? In C++11, the solution is the [final](https://en.cppreference.com/w/cpp/language/final) specifier.
```c++
struct Base {
    virtual void f();
};

struct Derived final : Base {  // now Derived is final; you cannot derive from it
    void f() override;
};

struct DD : Derived {  // error: a 'final' class type cannot be used as a base class
                       // ...
};
```

Srounds easy. However, in my interview, the interviewer didn't allow me to use `final`, so I couldn't answer it. Thanks to Stroustrup, I now know the answer. For older compilers, you can use a clumsy technique:

```c++
class Usable;

class Usable_lock {
    friend class Usable;

   private:
    Usable_lock() {}
    Usable_lock(const Usable_lock&) {}
};

class Usable : public virtual Usable_lock {
    // ...
   public:
    Usable();
    Usable(char*);
    // ...
};

Usable a;

class DD : public Usable {};  // ok, but...

DD dd;  // error: DD::DD() cannot access
        // Usable_lock::Usable_lock(): private  member
```


## Virtual in C++

### Virtual Function / Runtime polymorphism

[Geeksforgeeks: Virtual Function in C++](https://www.geeksforgeeks.org/virtual-function-cpp/)
- A virtual function is a member function which is declared within a base class and is re-defined (overridden) by a derived class.
- If we have created a virtual function in the base class and it is being overridden in the derived class, then we don’t need virtual keyword in the derived class.  e.g. `derived::print()` is automatically considered as a virtual function.
- **When you refer to a derived class object using a pointer or a reference to the base class**, you can call a virtual function for that object and execute the derived class’s version of the function. This is called runtime polymorphism.

Basic example:
```c++
// code adapted from https://www.geeksforgeeks.org/cpp-polymorphism/
#include <bits/stdc++.h>
using namespace std;

class base {
   public:
    virtual void print() { cout << "print base class" << endl; }

    void show() { cout << "show base class" << endl; }
};

class derived : public base {
   public:
    // print () is already virtual function in
    // derived class, we could also declared as
    // virtual void print () explicitly
    void print() { cout << "print derived class" << endl; }

    void show() { cout << "show derived class" << endl; }
};

int main() {
    base *bptr;
    derived d;
    bptr = &d;

    // Virtual function, binded at
    // runtime (Runtime polymorphism)
    // output: print derived class
    bptr->print();

    // Non-virtual function, binded
    // at compile time
    // output: show base class
    bptr->show();

    return 0;
}
```

### Virtual Inheritance